// @generated - This file is generated by atrium-codegen. DO NOT EDIT.
//!Structs for ATP client, implements all HTTP APIs of XRPC.
///Client struct for the ATP service.
pub struct AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub service: Service<T>,
}
impl<T> AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub fn new(xrpc: T) -> Self {
        Self {
            service: Service::new(std::sync::Arc::new(xrpc)),
        }
    }
}
pub struct Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub fm: fm::Service<T>,
    pub(crate) _phantom: core::marker::PhantomData<T>,
}
pub mod fm {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        #[cfg_attr(docsrs, doc(cfg(feature = "namespace-fmteal")))]
        #[cfg(feature = "namespace-fmteal")]
        pub teal: teal::Service<T>,
        pub(crate) _phantom: core::marker::PhantomData<T>,
    }
    #[cfg_attr(docsrs, doc(cfg(feature = "namespace-fmteal")))]
    #[cfg(feature = "namespace-fmteal")]
    pub mod teal {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub alpha: alpha::Service<T>,
            pub(crate) _phantom: core::marker::PhantomData<T>,
        }
        pub mod alpha {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub feed: feed::Service<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
            pub mod feed {
                pub struct Service<T>
                where
                    T: atrium_xrpc::XrpcClient + Send + Sync,
                {
                    pub(crate) xrpc: std::sync::Arc<T>,
                    pub(crate) _phantom: core::marker::PhantomData<T>,
                }
            }
        }
    }
}
impl<T> self::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            fm: fm::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> fm::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            #[cfg(feature = "namespace-fmteal")]
            teal: fm::teal::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
#[cfg(feature = "namespace-fmteal")]
impl<T> fm::teal::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            alpha: fm::teal::alpha::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
#[cfg(feature = "namespace-fmteal")]
impl<T> fm::teal::alpha::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            feed: fm::teal::alpha::feed::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
#[cfg(feature = "namespace-fmteal")]
impl<T> fm::teal::alpha::feed::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    pub async fn get_actor_feed(
        &self,
        params: crate::fm::teal::alpha::feed::get_actor_feed::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::feed::get_actor_feed::Output,
        crate::fm::teal::alpha::feed::get_actor_feed::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::feed::get_actor_feed::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_play(
        &self,
        params: crate::fm::teal::alpha::feed::get_play::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::feed::get_play::Output,
        crate::fm::teal::alpha::feed::get_play::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::feed::get_play::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
